#### 1.concurrenthashmap如何实现线程安全的
#### 2.get是否加锁了，不加锁为什么不会出现脏读
#### 3.map.size方法是否需要加锁
#### 4.volatile关键字的作用，是否能保证线程安全
#### 5.volatile可见性是如何实现的
#### 6.JVM运行时区域
#### 7.堆内存模型
#### 8.新生代和老年代各使用什么垃圾收集算法
#### 9.对象什么情况下会进入老年代
#### 10.GC过程是否会发生内存泄漏
#### 11.项目中JVM调优会调哪些参数
#### 12.Xms和Xmx是根据什么设置的
#### 13.内存溢出如何进行排查
#### 14.synchronized锁原理
#### 15.锁等待过程中线程会被放到队列里吗
#### 16.如果锁释放后，大量线程去竞争锁，导致CPU过高，如何解决这种问题
#### 17.只有一个线程，为什么还要用偏向锁
#### 18.mysql innodb聚集索引和非聚集索引的区别
#### 19.为什么要使用B+树作为索引的数据结构，为什么不用B树
#### 20.mysql事务的隔离级别，底层是如何实现的
#### 21.springboot的自动装配流程
#### 22.ES中term查询和match查询的区别
#### 23.ES中写入一条数据的过程是什么样的，以及如何保证数据不丢失
#### 24.ES深度分页
#### 25.滚动查询的缺点
#### 26.kafka集群zk中都存储哪些数据
#### 27.leader如果挂了怎么处理，如果ISR中没有内容了怎么处理
#### 28.动态代理的两种方式，有什么区别
#### 29.
